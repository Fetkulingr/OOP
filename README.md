# OOP
Данный репозиторий создан для изучения объектно-ориентированного программирования в python
# class_computer.py
Модуль class_computer.py Данный модуль демонстрирует применение основных принципов объектно-ориентированного программирования (ООП) при работе с базой данных SQLite.

Ключевые аспекты ООП, которые модуль демонстрирует:

1. Класс `Computer`: В этом классе определены характеристики и методы, относящиеся к компьютеру. Атрибуты `cpu`, `ram`, `hdd` и `hdd_type` представляют информацию о процессоре, оперативной памяти, жестком диске и его типе, соответственно. Также имеется атрибут `conn`, который представляет соединение с базой данных SQLite.

2. Метод `__init__(self)`: Этот метод выполняется при создании экземпляра класса `Computer`. Он инициализирует атрибуты класса и устанавливает соединение с базой данных.

3. Метод `create_table(self)`: Этот метод создает таблицу "computers" в базе данных SQLite, если она ещё не существует. Он использует SQL-запрос для создания таблицы с необходимыми столбцами.

4. Метод `get_user_input(self)`: Этот метод позволяет пользователю вводить информацию о компьютере, такую как модель процессора, объем оперативной памяти, объем жесткого диска и тип жесткого диска. Он использует словарь `cpu_options` для предоставления пользователю вариантов моделей процессоров и обрабатывает пользовательский ввод.

5. Метод `is_input_correct(self)`: Этот метод проверяет, все ли необходимые атрибуты класса `Computer` были заполнены. Если хотя бы один из них отсутствует, метод возвращает `False`, иначе `True`.

6. Метод `save_to_database(self)`: Этот метод выполняет сохранение информации о компьютере в базу данных. Он использует SQL-запрос `INSERT INTO` для добавления данных в таблицу "computers". Переданные данные вставляются в запрос через параметры, чтобы предотвратить SQL-инъекции.

Использование этого модуля позволяет пользователям вводить информацию о компьютере и сохранять ее в базе данных SQLite. Модуль демонстрирует принцип инкапсуляции. Класс Computer инкапсулирует данные компьютера (cpu, ram, hdd, hdd_type) и методы работы с ними (create_table, get_user_input, is_input_correct, save_to_database). Это означает, что данные и методы класса Computer скрыты от прямого доступа извне, и взаимодействие с ними происходит через публичный интерфейс класса (методы get_user_input и save_to_database), что способствует защите и контролю над данными.
# single_inheritance.py
Модуль single_inheritance.py. Данный модуль демонстрирует применение одиночного наследование классов в ООП. Класс UnitConverter наследует от класса Converter, что позволяет расширить функциональность базового класса. В данном случае, UnitConverter добавляет метод convert() для выполнения конверсии единиц измерения. Одиночное наследование классов означает, что класс может наследовать только от одного базового класса.
# multiple_inheritance.py
Модуль multiple_inheritance.py. Данный модуль демонстрирует множественного наследования классов в ООП. Код программы представляет собой реализацию игры "Крестики-нолики" с использованием объектно-ориентированного программирования (ООП). Основная идея игры - заполнить игровое поле 3x3 крестиками или ноликами в определенной комбинации, чтобы победить противника.

 Множественное наследование позволяет классу наследовать свойства и методы нескольких родительских классов. В данном случае класс `TicTacToe` наследуется от классов `Board`, `Player` и `AI`, чтобы получить функциональность игрового поля, игрока и искусственного интеллекта соответственно.

Класс `Board` представляет игровое поле. Он имеет конструктор, который создает список с 9 элементами, представляющими ячейки игрового поля. Метод `print_board` используется для вывода текущего состояния игрового поля на экран. Методы `is_board_full` и `is_winner` проверяют, заполнено ли игровое поле полностью и есть ли победитель соответственно.

Класс `Player` представляет игрока. Он инициализируется символом (крестиком или ноликом), которым игрок будет играть. Метод `make_move` запрашивает у игрока ввод номера ячейки, в которую он хочет сделать ход, и проверяет, является ли ячейка пустой. Если ячейка свободна, игрок делает ход, изменяя состояние игрового поля. В противном случае выводится сообщение об ошибке.

Класс `AI` представляет искусственный интеллект. Он также инициализируется символом, которым будет играть. Метод `make_move` генерирует случайное число, представляющее позицию свободной ячейки на игровом поле, и делает ход за искусственного интеллекта, изменяя состояние игрового поля.

Класс `TicTacToe` объединяет все компоненты игры. Он наследует функциональность классов `Board`, `Player` и `AI`. В конструкторе `TicTacToe` вызывается конструктор родительского класса `Board`, чтобы создать игровое поле. У `TicTacToe` также есть переменная `current_player`, которая указывает на текущего игрока.

В основной части программы создается объект `TicTacToe` и игра начинается. Игроки и искусственный интеллект поочередно совершают ходы, пока игра не закончится. По результатам ходов определяется победитель или ничья. Соответствующие сообщения выводятся на экран.

Таким образом, множественное наследование классов в данном коде позволяет легко объединить различные компоненты игры и расширить функциональность объекта `TicTacToe` за счет наследования свойств и методов от нескольких родительских классов.

# multilevel_inheritance.py
Модуль multilevel_inheritance.py. Данный модуль демонстрирует многоуровневое наследование классов. В представленном коде  коде программы есть пример многоуровневого наследования классов. Класс MultiLevelGame является подклассом класса Game, который в свою очередь является подклассом класса object.

Класс Game представляет собой игру с несколькими игроками. Он содержит методы для игры, включая метод play_game, который запускает игру, и метод print_scores, который выводит на экран текущие счета игроков.

Класс MultiLevelGame расширяет функциональность класса Game, добавляя возможность указания уровня игры. Метод play_game в классе MultiLevelGame переопределяет метод play_game из класса Game, чтобы добавить вывод информации о текущем уровне игры перед игрой и после её завершения.

Другие классы в коде включают класс Dice, который представляет собой кубик с заданным количеством граней и содержит метод roll для броска кубика. Есть также класс Player, представляющий игрока с именем и счетом, и методом play_turn, который имитирует ход игрока.

Программа создает двух игроков, player1 и player2, и создает объект класса Game, передавая этим игрокам в качестве аргумента. Затем программа запускает игру методом play_game и выводит текущие счета игроков методом print_scores.

Таким образом, многоуровневое наследование классов в коде позволяет наследовать и переопределять методы и атрибуты из разных уровней иерархии классов, что способствует модульности и переиспользованию кода.
# hierarchical_inheritance.py
Модуль hierarchical_inheritance.py. Данный код представляет собой простую игру викторина, реализованную с использованием иерархического наследования классов в объектно-ориентированном программировании.

Иерархическое наследование классов предполагает наличие главного класса (в данном случае класса `Question`), от которого наследуются другие классы (в данном случае классы `Game`). Класс `Game` расширяет (наследует) функциональность класса `Question`, добавляя дополнительные методы и поля для организации игрового процесса.

Класс `Question` представляет собой модель вопроса, содержащую текст вопроса (`question`), варианты ответа (`options`) и номер правильного ответа (`answer`). Класс имеет метод `display_question`, который выводит вопрос и варианты ответа на экран, и метод `check_answer`, который проверяет, совпадает ли ответ пользователя с правильным ответом.

Класс `Game` представляет собой модель игры, содержащую список вопросов (`questions`) и счет (`score`). Он имеет методы `start` и `end_game`. Метод `start` запускает игру, перемешивая вопросы в случайном порядке, выводит вопросы на экран, принимает ответы пользователя и проверяет их. Если ответ правильный, счет увеличивается. В конце игры метод `end_game` выводит окончательный счет.

Основная логика игры располагается в методе `start` класса `Game`. Она проходит по всем вопросам и в цикле выводит на экран каждый вопрос. Затем пользователь вводит свой ответ, который проверяется методом `check_answer`. В зависимости от результата проверки выводится соответствующее сообщение о правильности ответа, и счет обновляется. После завершения цикла игра выводит окончательный счет.

Таким образом, в данной программе иерархическое наследование классов используется для организации связи между общим классом `Question` и более конкретным классом `Game`, позволяя создать функциональность игры на основе модели вопросов.
